[PLATFORMS]
ALL

[PERMUTATIONS]

BLOOM_PASS_MODE

[COMPUTESHADER]

#include <Shaders/Common/Utils.h>

#include "BloomConstants.h"

Texture2D ColorTexture;

RWTexture2D<float4> Output;

#if BLOOM_PASS_MODE == BLOOM_PASS_MODE_LUMINANCE

[numthreads(POSTPROCESS_BLOCKSIZE , POSTPROCESS_BLOCKSIZE , 1)]
void main(uint3 threadId : SV_DispatchThreadID)
{
  // Out of bounds check
  if (any(int2(threadId.xy) >= ViewportSize.xy))
    return;

  float3 color = ColorTexture[threadId.xy].rgb;
  float3 luminance = saturate_16((GetLuminance(color) - BloomThreshold) * color * BloomIntensity);

  Output[threadId.xy] = float4(luminance, Output[threadId.xy].a);
}

#endif

#if BLOOM_PASS_MODE == BLOOM_PASS_MODE_UPSCALE_BLEND_MIP

// warning: passing "tex" as a parameter will cause spirv-cross to reflect nothing for this shader.
float3 tent_antiflicker_filter(float2 uv, float2 texel_size)
{
  // Tent
  float4 d  = texel_size.xyxy * float4(-1.0f, -1.0f, 1.0f, 1.0f) * 2.0f;
  float3 s1 = ColorTexture.SampleLevel(LinearClampSampler, uv + d.xy, 0.0f).rgb;
  float3 s2 = ColorTexture.SampleLevel(LinearClampSampler, uv + d.zy, 0.0f).rgb;
  float3 s3 = ColorTexture.SampleLevel(LinearClampSampler, uv + d.xw, 0.0f).rgb;
  float3 s4 = ColorTexture.SampleLevel(LinearClampSampler, uv + d.zw, 0.0f).rgb;

  // Luma weighted average
  float s1w = 1.0f / (GetLuminance(s1) + 1.0f);
  float s2w = 1.0f / (GetLuminance(s2) + 1.0f);
  float s3w = 1.0f / (GetLuminance(s3) + 1.0f);
  float s4w = 1.0f / (GetLuminance(s4) + 1.0f);
  float one_div_wsum = 1.0f / (s1w + s2w + s3w + s4w);

  return (s1 * s1w + s2 * s2w + s3 * s3w + s4 * s4w) * one_div_wsum;
}

[numthreads(POSTPROCESS_BLOCKSIZE , POSTPROCESS_BLOCKSIZE , 1)]
void main(uint3 threadId : SV_DispatchThreadID)
{
  // Out of bounds check
  if (any(int2(threadId.xy) >= ViewportSize.xy))
    return;

  const float2 uv        = (threadId.xy + 1.0f) * PixelSize;
  float3 upsampled_color = tent_antiflicker_filter(uv, PixelSize * 0.5f);
  Output[threadId.xy]    = float4(saturate_16(Output[threadId.xy].rgb + upsampled_color * 0.5f), Output[threadId.xy].a);
}

#endif

#if BLOOM_PASS_MODE == BLOOM_PASS_MODE_BLEND_FRAME

Texture2D MipTexture;

[numthreads(POSTPROCESS_BLOCKSIZE , POSTPROCESS_BLOCKSIZE , 1)]
void main(uint3 threadId : SV_DispatchThreadID)
{
  // Out of bounds check
  if (any(int2(threadId.xy) >= ViewportSize.xy))
    return;

  float4 color_frame    = ColorTexture[threadId.xy];
  float4 color_mip      = MipTexture[threadId.xy];
  Output[threadId.xy]   = saturate_16(color_frame + color_mip * BloomIntensity);
}

#endif
