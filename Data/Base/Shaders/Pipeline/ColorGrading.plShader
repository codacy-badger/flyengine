[PLATFORMS]
ALL


[PERMUTATIONS]
LUT_MODE


[COMPUTESHADER]

#include <Shaders/Common/Utils.h>

#include "ColorGradingConstants.h"

float3 AdjustContrast(float3 x)
{
  float3 x2 = x * x;
  float3 x3 = x2 * x;

  float a = ContrastParams.x;
  float b = ContrastParams.y;
  float c = ContrastParams.z;

  return a * x3 + b * x2 + c * x;
}

Texture2D InputTexture;
RWTexture2D<float4> Output;

#if LUT_MODE != LUT_MODE_NONE
Texture3D Lut1Texture;
#elif LUT_MODE == LUT_MODE_TWO
Texture3D Lut2Texture;
#endif

[numthreads(POSTPROCESS_BLOCKSIZE , POSTPROCESS_BLOCKSIZE , 1)]
void main(uint3 threadId : SV_DispatchThreadID)
{
  // Out of bounds check
  if (any(int2(threadId.xy) >= ViewportSize.xy))
    return;

  float3 color = InputTexture[threadId.xy].rgb;

  // Color grading with LUTs if enabled
#if LUT_MODE != LUT_MODE_NONE
  color = lerp(color, Lut1Texture.SampleLevel(LinearClampSampler, color, 0).rgb, Lut1Strength);
#if LUT_MODE == LUT_MODE_TWO
  color = lerp(color, Lut2Texture.SampleLevel(LinearClampSampler, color, 0).rgb, Lut2Strength);
#endif
#endif

  // Color grading with mood color
  float luminance = GetLuminance(color);

  float3 moodColor = lerp(0.0, MoodColor.rgb, saturate(luminance * 2.0));
  moodColor = lerp(moodColor, 1.0, saturate(luminance - 0.5) * 2.0);
  color = lerp(color, moodColor, saturate(luminance * MoodStrength));

  // Contrast adjustment
  color = saturate_16(lerp(luminance.xxx, color, Saturation));
  color = AdjustContrast(color);

  // Dither
  color  = sqrt(color);
  color += dither(threadId.xy * ViewportSize.xy);
  color *= color;

  Output[threadId.xy] = float4(color, InputTexture[threadId.xy].a);
}
