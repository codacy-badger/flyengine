[PLATFORMS]
ALL

[PERMUTATIONS]

BLOOM_PASS_MODE

[COMPUTESHADER]

#include <Shaders/Common/Utils.h>

#include "AmdSPDConstants.h"

#define A_GPU
#define A_HLSL
#define SPD_NO_WAVE_OPERATIONS
//#define SPD_LINEAR_SAMPLER

#include <Shaders/ThirdParty/FFX/ffx_a.h>

groupshared AF4 spd_intermediate[16][16];
groupshared AU1 spd_counter;

Texture2D ColorTexture;

globallycoherent RWStructuredBuffer<uint> AtomicCounter;
globallycoherent RWTexture2D<float4> DownsampleOutput[12];

AF4 SpdLoadSourceImage(ASU2 p, AU1 slice)
{
  float2 uv = (p + 0.5f) / ViewportSize.xy;
  return ColorTexture.SampleLevel(LinearClampSampler, uv, 0);
}

// Load from mip 5
AF4 SpdLoad(ASU2 pos, AU1 slice)
{
  return DownsampleOutput[5][pos];
}

void SpdStore(ASU2 pos, AF4 value, AU1 index, AU1 slice)
{
  DownsampleOutput[index][pos] = value;
}

AF4 SpdLoadIntermediate(AU1 x, AU1 y)
{
  return spd_intermediate[x][y];
}

void SpdStoreIntermediate(AU1 x, AU1 y, AF4 value)
{
  spd_intermediate[x][y] = value;
}

AF4 SpdReduce4(AF4 s1, AF4 s2, AF4 s3, AF4 s4)
{
  // luminance weighted average
  float s1w = 1 / (GetLuminance(s1) + 1);
  float s2w = 1 / (GetLuminance(s2) + 1);
  float s3w = 1 / (GetLuminance(s3) + 1);
  float s4w = 1 / (GetLuminance(s4) + 1);
  float one_div_wsum = 1.0 / (s1w + s2w + s3w + s4w);
  return (s1 * s1w + s2 * s2w + s3 * s3w + s4 * s4w) * one_div_wsum;
}

void SpdIncreaseAtomicCounter(AU1 slice)
{
  InterlockedAdd(AtomicCounter[0], 1, spd_counter);
}

AU1 SpdGetAtomicCounter()
{
  return spd_counter;
}

void SpdResetAtomicCounter(AU1 slice)
{
  AtomicCounter[0] = 0;
}

#include <Shaders/ThirdParty/FFX/ffx_spd.h>

[numthreads(256, 1, 1)]
void main(uint3 workGroupId : SV_GroupID, uint localThreadIndex : SV_GroupIndex)
{
  SpdDownsample(workGroupId.xy, localThreadIndex, MipCount, WorkGroupCount, workGroupId.z);
}