[PLATFORMS]
ALL

[PERMUTATIONS]
SHADING_QUALITY=SHADING_QUALITY_NORMAL // The deferred renderer only supports NORMAL shading quality
BLEND_MODE=BLEND_MODE_OPAQUE // At the lightning stage, the blend mode is always set to OPAQUE

CAMERA_MODE
VERTEX_SHADER_RENDER_TARGET_ARRAY_INDEX


[RENDERSTATE]
DepthTest = false
DepthTestFunc = CompareFunc_Less
DepthWrite = false
CullMode = CullMode_None


[VERTEXSHADER]
#include <Shaders/Pipeline/FullscreenTriangleVertexShader.h>


[GEOMETRYSHADER]
#include <Shaders/Pipeline/FullscreenTriangleStereoGeometryShader.h>


[PIXELSHADER]
#define USE_DECALS

#include <Shaders/Pipeline/FullscreenTriangleInterpolator.h>
static const float Epsilon = 0.0001f;

#define USE_MATERIAL_EMISSIVE
#define USE_MATERIAL_OCCLUSION
#define USE_MATERIAL_DISPLACEMENT
#define USE_MATERIAL_SPECULAR_CLEARCOAT
#define USE_MATERIAL_SPECULAR_ANISOTROPIC
#define USE_MATERIAL_SPECULAR_SHEEN
#define USE_MATERIAL_CAVITY
#define USE_MATERIAL_SUBSURFACE_COLOR
#define USE_MATERIAL_SUBSURFACE_PARAMS

#define USE_TWO_SIDED_LIGHTING

#define USE_FOG

#include <Shaders/Pipeline/FullscreenTriangleInterpolator.h>

#include <Shaders/Common/Utils.h>
#include <Shaders/Common/Lighting.h>

Texture2D AlbedoTexture;
Texture2D NormalTexture;
Texture2D MaterialTexture;
Texture2D MaterialAdvancedTexture;
Texture2D ClearCoatTexture;
Texture2D VelocityTexture;

RWTexture2D<float4> Output;

struct PS_GLOBALS
{
  PS_IN Input;
};

static PS_GLOBALS G;

// ----- Material --------------------------------

float3 GetNormal()
{
  return NormalTexture[G.Input.Position.xy].xyz;
}

float GetMetallic()
{
  float packed = MaterialTexture[G.Input.Position.xy].x;
  float metalic = 0;
  float roughness = 0;
    unpack_floats(roughness, metalic, packed);
  return metalic;
}

float3 GetDiffuseColor()
{
  return AlbedoTexture[G.Input.Position.xy].rgb;
}

float GetRoughness()
{
  float packed = MaterialTexture[G.Input.Position.xy].x;
  float metalic = 0;
  float roughness = 0;
    unpack_floats(roughness, metalic, packed);
  return roughness;
}

float3 GetEmissiveColor()
{
  float4 color = AlbedoTexture[G.Input.Position.xy];
  return color.rgb * color.a;
}

float GetOcclusion()
{
  float packed = MaterialTexture[G.Input.Position.xy].z;
  float occlusion = 0;
  float cavity = 0;
  unpack_floats(occlusion, cavity, packed);
  return occlusion;
}

float GetCavity()
{
  float packed = MaterialTexture[G.Input.Position.xy].z;
  float occlusion = 0;
  float cavity = 0;
  unpack_floats(occlusion, cavity, packed);
  return cavity;
}

float2 GetVelocity()
{
  return VelocityTexture[G.Input.Position.xy].xy;
}

void GetSpecularClearCoatParams(out float clearcoat, out float clearcoatRoughness, out float3 normal)
{
  normal = ClearCoatTexture[G.Input.Position.xy].xyz;
  float packed = ClearCoatTexture[G.Input.Position.xy].a;
  unpack_floats(clearcoat, clearcoatRoughness, packed);
}

void GetSpecularAnisotopicParams(out float anisotropic, out float rotation)
{
  float packed = MaterialAdvancedTexture[G.Input.Position.xy].a;
  unpack_floats(anisotropic, rotation, packed);
}

void GetSpecularSheenParams(out float sheen, out float tintFactor)
{
  float packed = MaterialTexture[G.Input.Position.xy].a;
  unpack_floats(sheen, tintFactor, packed);
}

void GetSubsurface(out float3 subsurfaceColor, out float subsurfaceScatterPower, out float subsurfaceStrength)
{
  subsurfaceColor = MaterialAdvancedTexture[G.Input.Position.xy].rgb;
    
  float packed = MaterialTexture[G.Input.Position.xy].g;
  unpack_floats(subsurfaceStrength, subsurfaceScatterPower, packed);
}

void GetSpecularColor(out float3 specularColor)
{
    float packed = VelocityTexture[G.Input.Position.xy].z;
    unpack_floats(specularColor.x, specularColor.y, packed);
    specularColor.z = VelocityTexture[G.Input.Position.xy].a;
}

plMaterialData FillMaterialData()
{
  plMaterialData matData;

  matData.worldPosition = SampleScenePosition(G.Input.Position.xy);
  matData.worldNormal = GetNormal();
  matData.vertexNormal = GetNormal();
  matData.emissiveColor = GetEmissiveColor();
  matData.diffuseColor = GetDiffuseColor();
  matData.refractionColor = float4(0, 0, 0, 1);
  matData.roughness = GetRoughness();
  matData.perceptualRoughness = PerceptualRoughnessFromRoughness(matData.roughness);
  matData.metalness = GetMetallic();
  matData.occlusion = GetOcclusion();
  matData.opacity = 1.0f;
  matData.cavity = GetCavity();
  matData.velocity = GetVelocity();

  GetSpecularColor(matData.specularColor);
//  matData.specularColor = lerp(0.04f, matData.diffuseColor, matData.metalness);

  GetSpecularClearCoatParams(matData.clearcoat, matData.clearcoatRoughness, matData.clearcoatNormal);
  GetSpecularAnisotopicParams(matData.anisotropic, matData.anisotropicRotation);
  GetSpecularSheenParams(matData.sheen, matData.sheenTintFactor);

  GetSubsurface(matData.subsurfaceColor, matData.subsurfaceScatterPower, matData.subsurfaceStrength);

  return matData;
}

// ---------------------------------------------------------

float4 main(PS_IN Input) : SV_Target
{
#if CAMERA_MODE == CAMERA_MODE_STEREO
  s_ActiveCameraEyeIndex = Input.RenderTargetArrayIndex;
#endif

  G.Input = Input;

  float depth = SampleSceneDepth(Input.Position.xy);
  float3 screenPos = float3(Input.Position.xy, depth);

  plMaterialData matData = FillMaterialData();

  plPerClusterData clusterData = GetClusterData(screenPos);
  uint gameObjectId = unpack_float16_to_uint32(NormalTexture[Input.Position.xy].w);

#if defined(USE_DECALS)
  ApplyDecals(matData, clusterData, gameObjectId);
#endif

  AccumulatedLight light = CalculateLighting(matData, clusterData, screenPos, true);

  float3 litColor = light.diffuseLight + light.specularLight;
  litColor *= Exposure;
  litColor += matData.emissiveColor;
  litColor *= matData.cavity;
  
  litColor = ApplyFog(litColor, matData.worldPosition);

  return float4(litColor, matData.opacity);
}