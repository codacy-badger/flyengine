[PLATFORMS]

ALL


[PERMUTATIONS]

SHADING_MODE = SHADING_MODE_LIT // Always use LIT mode
SHADING_QUALITY = SHADING_QUALITY_NORMAL // Not compatible with SIMPLE shading quality

BLEND_MODE

TWO_SIDED

// SYSTEM permutations
FLIP_WINDING
GAMEOBJECT_VELOCITY
RENDER_PASS
CAMERA_MODE
FORWARD_PASS_WRITE_DEPTH
// SYSTEM permutations


[MATERIALPARAMETER]

Permutation TWO_SIDED;
Permutation BLEND_MODE;

float MaskThreshold @Default(0.25);

float2 UVOffset @Default(float2(0.0, 0.0));
float2 UVScale @Default(float2(1.0, 1.0));

bool UseBaseTexture;
Texture2D BaseTexture;
Color BaseColor @Default(Color(1.0, 1.0, 1.0));

bool UseNormalTexture;
Texture2D NormalTexture;
float NormalIntensity @Default(1.0) @Clamp(0.0, 2.0);

bool UseRoughnessTexture;
Texture2D RoughnessTexture;
float RoughnessValue @Default(0.7) @Clamp(0.0, 2.0);

bool UseMetallicTexture;
Texture2D MetallicTexture;
float MetallicValue @Default(0.0) @Clamp(0.0, 2.0);

bool UseSpecularTexture;
Texture2D SpecularTexture;
Color SpecularColor @Default(Color(0.04, 0.04, 0.04));

bool UseEmissiveTexture;
Texture2D EmissiveTexture;
Color EmissiveColor @Default(Color(0.0, 0.0, 0.0));

bool UseOcclusionTexture;
Texture2D OcclusionTexture;

float BendStrength @Default(0.1);
float LeafFlutterStrength @Default(0.1);
float BranchFlutterStrength @Default(0.1);

[RENDERSTATE]

#include <Shaders/Materials/MaterialState.h>


[SHADER]

#define USE_COLOR0
#define USE_NORMAL
#define USE_TANGENT
#define USE_TANGENT_POS
#define USE_TEXCOORD0


// This enables special editor render modes:
#if RENDER_PASS == RENDER_PASS_EDITOR
#define USE_DEBUG_INTERPOLATOR
#endif

#include <Shaders/Common/Utils.h>

CONSTANT_BUFFER(plMaterialConstants, 1)
{
  FLOAT2(UVOffset);
  FLOAT2(UVScale);

  COLOR4F(BaseColor);

  COLOR4F(SpecularColor);

  COLOR4F(EmissiveColor);

  COLOR4F(SubsurfaceColor);

  FLOAT1(MaskThreshold);
  FLOAT1(NormalIntensity);
  FLOAT1(RoughnessValue);
  FLOAT1(MetallicValue);


  BOOL1(UseBaseTexture);
  BOOL1(UseNormalTexture);
  BOOL1(UseRoughnessTexture);
  BOOL1(UseMetallicTexture);

  BOOL1(UseSpecularTexture);
  BOOL1(UseEmissiveTexture);
  BOOL1(UseOcclusionTexture);
  BOOL1(UseSubsurfaceTexture);

  FLOAT1(BendStrength);
  FLOAT1(LeafFlutterStrength);
  FLOAT1(BranchFlutterStrength);
  FLOAT1(Unused);
};


[VERTEXSHADER]

#if GAMEOBJECT_VELOCITY
#define USE_VELOCITY
#endif

#include <Shaders/Materials/MaterialVertexShader.h>

void MainBending(inout float3 pos, float2 wind, float bendScale)
{
  float fLength = length(pos);
  float fBF = pos.y *  bendScale;
  fBF += 1.0;
  fBF *= fBF;
  fBF = fBF * fBF - fBF;
  float3 vNewPos = pos;
  vNewPos.xz += wind.xy * fBF;
  pos.xyz = normalize(vNewPos.xyz)* fLength;
}

float3 BendPosition(float3 position, float positionBend, float3 wind, float flutter, float leafStiffness, float branchStiffness)
{
  float distToAnchor = length(position);

  position.x += wind.x * positionBend + (flutter * leafStiffness);
  position.y += wind.y * positionBend + (flutter * branchStiffness);
  position.z += flutter * leafStiffness;

  return normalize(position) * distToAnchor;
}

VS_OUT main(VS_IN Input)
{
  VS_OUT Output = FillVertexData(Input);

  Output.TexCoord0 = (Output.TexCoord0 + UVOffset) * UVScale;

  plPerInstanceData data = GetInstanceData();
  float4x4 objectToWorld = TransformToMatrix(data.ObjectToWorld);
  float3 localPosition = Input.Position.xyz;

//  float3 scale;
//  scale.x = length(objectToWorld._m00_m10_m20);
//  scale.y = length(objectToWorld._m01_m11_m21);
//  scale.z = length(objectToWorld._m02_m12_m22);
//
//  // shift time by world space position (x, y) to make trees standing next to each other flutter out of phase
  float phasedTime = WorldTime + objectToWorld._m03 + objectToWorld._m13;


  float fLeafFlutterAmplitude = 0.01;
  float fFastFlutterWindSpeed = 25.0; // constant
  float fMinFlutterWindSpeed = 1.0; // constant (always have some flutter)
  float fMaxFlutterWindSpeed = 20.0; // constant
  float fFlutterPhaseShift = 1.9; // constant (sin(x) + sin(x*1.9) looks good)
  float fSlowFlutterSpeed = 0.1; // constant (blend between slow and fast)
  float fFastFlutterSpeed = 10; // constant

  float fBendAndFlutterStrength = BendStrength * 0.1;
  float fBranchLevel = 1.0;
  float fFlutterPhase = Input.Color0.g;
  float windStrength = length(data.Wind);


  [branch]
  if (fBranchLevel == 0)
  {
    localPosition = BendPosition(localPosition, fBendAndFlutterStrength,  data.Wind * 0.1, 0, 0, 0);
  }
  else
  {
    float2 flutterSamplePos = float2(fFlutterPhase + phasedTime, (fFlutterPhase + phasedTime) * fFlutterPhaseShift);
    float flutterAmount = fLeafFlutterAmplitude * clamp(windStrength, fMinFlutterWindSpeed, fMaxFlutterWindSpeed);

    float2 flutterSlow = sin(flutterSamplePos * fSlowFlutterSpeed);
    float2 flutterFast = sin(flutterSamplePos * fFastFlutterSpeed);
    float2 flutter = lerp(flutterSlow, flutterFast, clamp(windStrength / fFastFlutterWindSpeed, 0, 1)) * flutterAmount;

    localPosition = BendPosition(localPosition, fBendAndFlutterStrength,  data.Wind * 0.1, (flutter.x + flutter.y) * 0.1,LeafFlutterStrength *  Input.Color0.r, (1.0 - Input.Color0.b) * BranchFlutterStrength);
  }

  //localPosition = BendPosition(localPosition, fBendAndFlutterStrength, data.Wind * 0.1, 0.0);

  float4 worldPosition = mul(objectToWorld, float4(localPosition, 1));

  Output.WorldPosition = worldPosition;

  Output.Position = mul(GetWorldToScreenMatrix(), worldPosition);

  return Output;
}


[GEOMETRYSHADER]

#if GAMEOBJECT_VELOCITY
#define USE_VELOCITY
#endif

#include <Shaders/Materials/MaterialStereoGeometryShader.h>

[PIXELSHADER]

#define USE_MATERIAL_EMISSIVE
#define USE_MATERIAL_OCCLUSION

#define USE_TWO_SIDED_LIGHTING

#define USE_DECALS
#define USE_FOG

#if GAMEOBJECT_VELOCITY
#define USE_VELOCITY
#endif


#include <Shaders/Materials/MaterialPixelShader.h>

Texture2D BaseTexture;
SamplerState BaseTexture_AutoSampler;

Texture2D NormalTexture;
SamplerState NormalTexture_AutoSampler;

Texture2D MetallicTexture;
SamplerState MetallicTexture_AutoSampler;

Texture2D RoughnessTexture;
SamplerState RoughnessTexture_AutoSampler;

Texture2D EmissiveTexture;
SamplerState EmissiveTexture_AutoSampler;

Texture2D OcclusionTexture;
SamplerState OcclusionTexture_AutoSampler;

Texture2D SpecularTexture;
SamplerState SpecularTexture_AutoSampler;

Texture2D CavityTexture;
SamplerState CavityTexture_AutoSampler;

Texture2D DisplacementTexture;
SamplerState DisplacementTexture_AutoSampler;

Texture2D ClearcoatInfluenceTexture;
SamplerState ClearcoatInfluenceTexture_AutoSampler;

Texture2D ClearcoatNormalTexture;
SamplerState ClearcoatNormalTexture_AutoSampler;

Texture2D ClearcoatRoughnessTexture;
SamplerState ClearcoatRoughnessTexture_AutoSampler;


float3 GetBaseColor()
{
  // BaseColor comes from the material itself
  // GetInstanceData() comes from the specific mesh instance
  float3 baseColor = BaseColor.rgb * GetInstanceData().Color.rgb;

  [branch]
  if (UseBaseTexture)
  {
    float3 color = BaseTexture.Sample(BaseTexture_AutoSampler, G.Input.TexCoord0.xy).rgb;
    // color = degamma(color);
    baseColor *= color;
  }

  return baseColor;
}

#if defined(USE_MATERIAL_SUBSURFACE_COLOR)
float3 GetSubsurfaceColor()
{
  [branch]
  if (UseSubsurfaceTexture)
  {
    return SubsurfaceTexture.Sample(SubsurfaceTexture_AutoSampler, G.Input.TexCoord0.xy).rgb;
  }

  return SubsurfaceColor.rgb;
}
#endif

float3 GetNormal()
{
  [branch]
  if (UseNormalTexture)
  {
    // per-pixel normal read from the provided texture
    float3 normalTS = DecodeNormalTexture(NormalTexture.Sample(NormalTexture_AutoSampler, G.Input.TexCoord0.xy), NormalIntensity);
    return TangentToWorldSpace(normalTS);
  }
  else
  {
    // interpolated vertex normals
    return G.Input.Normal;
  }
}

float GetReflectance()
{
  return 0.5f;
}

float GetMetallic()
{
  [branch]
  if (UseMetallicTexture)
  {
    return MetallicValue * MetallicTexture.Sample(MetallicTexture_AutoSampler, G.Input.TexCoord0.xy).r;
  }
  else
  {
    return MetallicValue;
  }
}

float3 GetDiffuseColor()
{
  [branch]
  if (UseSpecularTexture)
  {
    return GetBaseColor();
  }
  else
  {
    return lerp(GetBaseColor(), 0.0f, GetMetallic());
  }
}

float3 GetSpecularColor()
{
  [branch]
  if (UseSpecularTexture)
  {
    return SpecularTexture.Sample(SpecularTexture_AutoSampler, G.Input.TexCoord0.xy).rgb;
  }
  else
  {
    return lerp(SpecularColor.rgb, GetBaseColor(), GetMetallic());
  }
}

float GetRoughness()
{
  [branch]
  if (UseRoughnessTexture)
  {
    return RoughnessValue * RoughnessTexture.Sample(RoughnessTexture_AutoSampler, G.Input.TexCoord0.xy).r;
  }
  else
  {
    return RoughnessValue;
  }
}

float GetOpacity()
{
  float opacity = BaseColor.a * GetInstanceData().Color.a;

  [branch]
  if (UseBaseTexture)
  {
    opacity *= BaseTexture.Sample(BaseTexture_AutoSampler, G.Input.TexCoord0.xy).a;
  }

  #if BLEND_MODE == BLEND_MODE_MASKED
    return opacity - MaskThreshold;
  #else
    return opacity;
  #endif
}

float3 GetEmissiveColor()
{
  [branch]
  if (UseEmissiveTexture)
  {
    return EmissiveTexture.Sample(EmissiveTexture_AutoSampler, G.Input.TexCoord0.xy).rgb * EmissiveColor.rgb;
  }
  else
  {
    return EmissiveColor.rgb;
  }
}

float GetOcclusion()
{
  [branch]
  if (UseOcclusionTexture)
  {
    return OcclusionTexture.Sample(OcclusionTexture_AutoSampler, G.Input.TexCoord0.xy).r;
  }
  else
  {
    return 1.0f;
  }
}