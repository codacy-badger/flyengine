#include <Foundation/Application/Application.h>
#include <Foundation/CodeUtils/Tokenizer.h>
#include <Foundation/Configuration/Startup.h>
#include <Foundation/Containers/HashSet.h>
#include <Foundation/Containers/HashTable.h>
#include <Foundation/Containers/Map.h>
#include <Foundation/Containers/Set.h>
#include <Foundation/IO/FileSystem/DataDirTypeFolder.h>
#include <Foundation/IO/FileSystem/FileReader.h>
#include <Foundation/IO/FileSystem/FileSystem.h>
#include <Foundation/IO/JSONReader.h>
#include <Foundation/Logging/ConsoleWriter.h>
#include <Foundation/Logging/HTMLWriter.h>
#include <Foundation/Logging/Log.h>
#include <Foundation/Logging/VisualStudioWriter.h>
#include <Foundation/Memory/LinearAllocator.h>
#include <Foundation/Strings/PathUtils.h>
#include <Foundation/Strings/String.h>
#include <Foundation/Strings/StringBuilder.h>
#include <Foundation/System/SystemInformation.h>
#include <Foundation/Threading/TaskSystem.h>
#include <Foundation/Types/UniquePtr.h>

class plDependencyAnalysisApp;


bool g_bVerbose = false;

namespace
{
  using DependencyListType = plHashSet<plString>;

  struct CompilationUnitContext
  {
    DependencyListType m_dependencies;
    plDynamicArray<plString> m_IncludeDirectories;
    plHashTable<plString, plString> m_includeCache;
  };
  using CompilationUnitListType = plHashTable<plString, CompilationUnitContext>;

  PL_ALWAYS_INLINE void SkipWhitespace(plToken& ref_token, plUInt32& i, const plDeque<plToken>& tokens)
  {
    while (ref_token.m_iType == plTokenType::Whitespace)
    {
      ref_token = tokens[++i];
    }
  }

  PL_ALWAYS_INLINE void SkipLine(plToken& ref_token, plUInt32& i, const plDeque<plToken>& tokens)
  {
    while (ref_token.m_iType != plTokenType::Newline && ref_token.m_iType != plTokenType::EndOfFile)
    {
      ref_token = tokens[++i];
    }
  }

  // Json parser for command_line.json files generated by cmake
  class CompileCommandsParser : public plJSONParser
  {
  public:
    struct CompileCommand
    {
      plString command;
      plString file;
    };

    void Initialize(plStreamReader& inout_stream)
    {
      SetInputStream(inout_stream);
    }

    plResult GetNextCommand(CompileCommand& out_command)
    {
      while (!m_bObjectOpen)
      {
        if (!ContinueParsing())
        {
          return PL_FAILURE;
        }
      }

      while (m_bObjectOpen)
      {
        if (!ContinueParsing())
        {
          return PL_FAILURE;
        }
      }

      out_command = m_Command;
      return PL_SUCCESS;
    }

  private:
    // Inherited via plJSONParser
    virtual bool OnVariable(plStringView sVarName) override
    {
      bool needed = false;

      if (sVarName == "file")
      {
        needed = true;
        m_pNextVar = &m_Command.file;
      }
      else if (sVarName == "command")
      {
        needed = true;
        m_pNextVar = &m_Command.command;
      }

      if (!needed && sVarName != "directory" && sVarName != "output")
      {
        plStringBuilder fmt;
        fmt.SetFormat("Unknown variable '{0}'", sVarName);
        ParsingError(fmt.GetView(), false);
      }
      return needed;
    }

    virtual void OnReadValue(plStringView sValue) override
    {
      if (m_pNextVar == nullptr)
      {
        ParsingError("Unexpected value", true);
        return;
      }

      *m_pNextVar = sValue;
      m_pNextVar = nullptr;
    }

    virtual void OnReadValue(double fValue) override
    {
    }

    virtual void OnReadValue(bool bValue) override
    {
    }

    virtual void OnReadValueNULL() override
    {
    }

    virtual void OnBeginObject() override
    {
      if (!m_bOuterArrayOpen || m_bObjectOpen)
      {
        ParsingError("Unexpected object begin", true);
        return;
      }

      m_bObjectOpen = true;
      m_Command = {};
    }

    virtual void OnEndObject() override
    {
      if (!m_bObjectOpen)
      {
        ParsingError("Unexpected object end", true);
        return;
      }
      m_bObjectOpen = false;
    }

    virtual void OnBeginArray() override
    {
      if (!m_bOuterArrayOpen)
      {
        m_bOuterArrayOpen = true;
      }
      else
      {
        ParsingError("Unexpected array begin", true);
      }
    }

    virtual void OnEndArray() override
    {
      if (m_bOuterArrayOpen)
      {
        m_bOuterArrayOpen = false;
      }
      else
      {
        ParsingError("Unexpected array end", true);
      }
    }

    bool m_bOuterArrayOpen = false;
    bool m_bObjectOpen = false;
    plString* m_pNextVar = nullptr;
    CompileCommand m_Command;
  };

  // plOSFile::ExistsFile is quite slow, cache the results thread local to avoid lock contetion
  struct ExistsFileCache
  {
    static thread_local plHashTable<plString, bool> m_ExistsFileCache;

    static bool ExistsFile(plStringView sFile)
    {
      bool existedAlready = false;
      bool returnValue = false;
      {
        bool& result = m_ExistsFileCache.FindOrAdd(sFile, &existedAlready);
        if (!existedAlready)
        {
          result = plOSFile::ExistsFile(sFile);
        }
        returnValue = result;
      }
      return returnValue;
    }
  };

  thread_local plHashTable<plString, bool> ExistsFileCache::m_ExistsFileCache;

  // Task to parse a single header file
  // stores the results in the task, need to be extracted after finish using MoveOutDependencies
  class ParseHeaderFileTask : public plTask
  {
  public:
    ParseHeaderFileTask()
    {
      ConfigureTask("ParseHeaderFileTask", plTaskNesting::Maybe);
    }

    void Initialize(plStringView sPath)
    {
      m_sPath = sPath;
    }

    virtual void Execute() override;

    plStringView GetPath() const { return m_sPath; }
    plHashSet<plString>&& MoveOutDependencies() { return std::move(m_Dependencies); }

  private:
    plString m_sPath;
    plHashSet<plString> m_Dependencies;
    plTaskGroupID m_TaskGroup;
  };

  // Task to collect the dependencies of a single compilation unit
  // Might need to run multiple times (call HasWorkLeft to know if it needs to be executed again)
  // Needs to spawn other tasks when HasWorkLeft returns true: see ScheduleRemainingWork
  class CollectDependenciesTask : public plTask
  {
  public:
    CollectDependenciesTask()
    {
      ConfigureTask("CollectDependenciesTask", plTaskNesting::Maybe);
    }

    void Initialize(plStringView sPath, CompilationUnitContext& ref_context, plDependencyAnalysisApp& ref_app)
    {
      m_sPath = sPath;
      m_pContext = &ref_context;
      m_pApp = &ref_app;
    }

    void OnParsingFinished(plTaskGroupID taskGroupID);

    virtual void Execute() override;

    bool HasWorkLeft() const { return m_LeftoverFiles.GetCount() > 0; }

    void ScheduleRemainingWork();

  private:
    plStringView m_sPath;
    CompilationUnitContext* m_pContext = nullptr;
    plDependencyAnalysisApp* m_pApp = nullptr;
    plDynamicArray<plSharedPtr<ParseHeaderFileTask>> m_ParseTasks;
    plDynamicArray<plString> m_LeftoverFiles;
    plTaskGroupID m_ParseTaskGroup;
  };
} // namespace

/*
* This application finds all dependencies of a given compile setup.
*
* Currently requires a compile_commands.json generated with cmake targeting the clang compiler
*
* Basic flow
* - Parse the compile_command.json to find all .cpp files (compilation units)
* - Parse each compilation unit, and find all headers it includes
* - Parse all found headers and note their dependencies (storing only the unresolved paths)
* - For each compilation unit resolve all dependencies by doing a breadth first search in parallel
*   + Whenever we encounter a header file we have not seen yet, we need to parse it
* - Write out the results into a json file. For each compilation units all header dependencies will be listed.
*/
class plDependencyAnalysisApp : public plApplication
{
private:
  friend CollectDependenciesTask;

  plString m_sCompileCommandsPath;
  bool m_bHadErrors;
  bool m_bHadSeriousWarnings;
  bool m_bHadWarnings;
  plDynamicArray<plString> m_IgnorePatterns;
  plString m_sOutputPath;

  CompilationUnitListType m_CompilationUnits;
  plMutex m_HeaderDependenciesMutex;
  plHashTable<plString, DependencyListType> m_HeaderDependencies;

  plMutex m_HeaderParsingScheduledMutex;
  plHashSet<plString> m_HeaderParsingScheduled;

public:
  using SUPER = plApplication;

  plDependencyAnalysisApp()
    : plApplication("DependencyAnalysis")
  {
    m_bHadErrors = false;
    m_bHadSeriousWarnings = false;
    m_bHadWarnings = false;
  }

  /// Makes sure the apps return value reflects whether there were any errors or warnings
  static void LogInspector(const plLoggingEventData& eventData)
  {
    plDependencyAnalysisApp* app = (plDependencyAnalysisApp*)plApplication::GetApplicationInstance();

    switch (eventData.m_EventType)
    {
      case plLogMsgType::ErrorMsg:
        app->m_bHadErrors = true;
        break;
      case plLogMsgType::SeriousWarningMsg:
        app->m_bHadSeriousWarnings = true;
        break;
      case plLogMsgType::WarningMsg:
        app->m_bHadWarnings = true;
        break;

      default:
        break;
    }
  }


  plResult ParseArray(const plVariant& value, plHashSet<plString>& ref_dst)
  {
    if (!value.CanConvertTo<plVariantArray>())
    {
      plLog::Error("Expected array");
      return PL_FAILURE;
    }
    auto a = value.Get<plVariantArray>();
    const auto arraySize = a.GetCount();
    for (plUInt32 i = 0; i < arraySize; i++)
    {
      auto& el = a[i];
      if (!el.CanConvertTo<plString>())
      {
        plLog::Error("Value {0} at index {1} can not be converted to a string. Expected array of strings.", el, i);
        return PL_FAILURE;
      }
      plStringBuilder file = el.Get<plString>();
      file.ToLower();
      ref_dst.Insert(file);
    }
    return PL_SUCCESS;
  }

  virtual void AfterCoreSystemsStartup() override
  {
    plGlobalLog::AddLogWriter(plLogWriter::Console::LogMessageHandler);
    plGlobalLog::AddLogWriter(plLogWriter::VisualStudio::LogMessageHandler);
    plGlobalLog::AddLogWriter(LogInspector);


    plSystemInformation info = plSystemInformation::Get();
    const plInt32 iCpuCores = info.GetCPUCoreCount();
    plTaskSystem::SetWorkerThreadCount(iCpuCores);

    if (GetArgumentCount() < 2)
    {
      plLog::Info("DependencyAnalysis.exe [options] path/to/compile_commands.json");
      plLog::Info("");
      plLog::Info("-i [pattern] --ignorePattern [pattern]    ignore all cpp/h files containing this pattern");
      plLog::Info("-v           --verbose                    enable verbose logging");
      plLog::Info("-o [path]    --output [path]              path to the output json file");
      plLog::Info("");

      plLog::Error("No command line arguments given.");
      return;
    }

    // Add the empty data directory to access files via absolute paths
    plFileSystem::AddDataDirectory("", "App", ":", plFileSystem::AllowWrites).IgnoreResult();

    // pass the absolute path to the directory that should be scanned as the first parameter to this application
    plStringBuilder sCompileCommandsPath;

    auto numArgs = GetArgumentCount();
    auto shortIgnore = plStringView("-i");
    auto longIgnore = plStringView("--ignorePattern");
    auto shortVerbose = plStringView("-v");
    auto longVerbose = plStringView("--verbose");
    auto shortOutput = plStringView("-o");
    auto longOutput = plStringView("--output");
    for (plUInt32 argi = 1; argi < numArgs; argi++)
    {
      auto arg = plStringView(GetArgument(argi));
      if (arg == shortIgnore || arg == longIgnore)
      {
        if (numArgs <= argi + 1)
        {
          plLog::Error("Missing path for {0}", arg);
          return;
        }
        plStringBuilder ignorePattern = GetArgument(argi + 1);
        if (ignorePattern == shortIgnore || ignorePattern == longIgnore || ignorePattern == shortIgnore || ignorePattern == longIgnore || ignorePattern == shortOutput || ignorePattern == longOutput)
        {
          plLog::Error("Missing path for {0} found {1} instead", arg, ignorePattern.GetView());
          return;
        }
        argi++;
        ignorePattern.MakeCleanPath();
        m_IgnorePatterns.PushBack(ignorePattern);
      }
      else if (arg == shortVerbose || arg == longVerbose)
      {
        g_bVerbose = true;
      }
      else if (arg == shortOutput || arg == longOutput)
      {
        if (!m_sOutputPath.IsEmpty())
        {
          plLog::Error("Output path given multiple times");
          return;
        }
        if (numArgs <= argi + 1)
        {
          plLog::Error("Missing path for {0}", arg);
          return;
        }
        plStringBuilder outputPath = GetArgument(argi + 1);
        if (outputPath == shortIgnore || outputPath == longIgnore || outputPath == shortIgnore || outputPath == longIgnore || outputPath == shortOutput || outputPath == longOutput)
        {
          plLog::Error("Missing path for {0} found {1} instead", arg, outputPath.GetView());
          return;
        }
        if (!outputPath.IsAbsolutePath())
        {
          outputPath = plOSFile::GetCurrentWorkingDirectory();
          outputPath.AppendPath(GetArgument(argi + 1));
        }
        outputPath.MakeCleanPath();
        argi++;
        m_sOutputPath = outputPath;
      }
      else
      {
        if (sCompileCommandsPath.IsEmpty())
        {
          sCompileCommandsPath = arg;
          sCompileCommandsPath.MakeCleanPath();
        }
        else
        {
          plLog::Error("Currently only one directory is supported for searching. Did you forget -i|--includeDir? {0}", arg);
        }
      }
    }

    if (!plPathUtils::IsAbsolutePath(sCompileCommandsPath.GetData()))
      plLog::Error("The given path is not absolute: '{0}'", sCompileCommandsPath);

    m_sCompileCommandsPath = sCompileCommandsPath;

    if (m_sOutputPath.IsEmpty())
    {
      plLog::Error("No output path given. Use -o or --output");
    }
  }

  virtual void BeforeCoreSystemsShutdown() override
  {
    SetReturnCode(0);

    plGlobalLog::RemoveLogWriter(LogInspector);
    plGlobalLog::RemoveLogWriter(plLogWriter::Console::LogMessageHandler);
    plGlobalLog::RemoveLogWriter(plLogWriter::VisualStudio::LogMessageHandler);
  }

  static plResult ReadEntireFile(plStringView sFile, plStringBuilder& out_sContents)
  {
    out_sContents.Clear();

    plFileReader File;
    if (File.Open(sFile) == PL_FAILURE)
    {
      plLog::Error("Could not open for reading: '{0}'", sFile);
      return PL_FAILURE;
    }

    plDynamicArray<plUInt8> FileContent;

    plUInt8 Temp[4024];
    plUInt64 uiRead = File.ReadBytes(Temp, PL_ARRAY_SIZE(Temp));

    while (uiRead > 0)
    {
      FileContent.PushBackRange(plArrayPtr<plUInt8>(Temp, (plUInt32)uiRead));

      uiRead = File.ReadBytes(Temp, PL_ARRAY_SIZE(Temp));
    }

    FileContent.PushBack(0);

    if (!plUnicodeUtils::IsValidUtf8((const char*)&FileContent[0]))
    {
      plLog::Error("The file \"{0}\" contains characters that are not valid Utf8. This often happens when you type special characters in "
                   "an editor that does not save the file in Utf8 encoding.",
        sFile);
      return PL_FAILURE;
    }

    out_sContents = (const char*)&FileContent[0];

    return PL_SUCCESS;
  }

  static plResult FindIncludeFile(plStringView sPath, CompilationUnitContext& inout_context, plStringBuilder& out_sPath)
  {
    if (sPath.IsAbsolutePath())
    {
      out_sPath = sPath;
      out_sPath.MakeCleanPath();
      if (ExistsFileCache::ExistsFile(sPath))
      {
        return PL_SUCCESS;
      }
      else
      {
        return PL_FAILURE;
      }
    }

    for (auto& includeDir : inout_context.m_IncludeDirectories)
    {
      out_sPath = includeDir;
      out_sPath.AppendPath(sPath);
      out_sPath.MakeCleanPath();
      if (ExistsFileCache::ExistsFile(out_sPath))
      {
        return PL_SUCCESS;
      }
    }

    return PL_FAILURE;
  }

  bool IgnorePath(const plStringBuilder& sBuilder)
  {
    for (auto& ignore : m_IgnorePatterns)
    {
      if (sBuilder.FindSubString(ignore))
      {
        return true;
      }
    }
    return false;
  }

  void ParseCompileCommandsJson()
  {
    plFileReader reader;
    reader.Open(m_sCompileCommandsPath).AssertSuccess(); // TODO error handling

    CompileCommandsParser parser;
    parser.SetLogInterface(plLog::GetThreadLocalLogSystem());
    parser.Initialize(reader);

    plDynamicArray<plStringView> commandParts;

    plStringBuilder tmpPath;

    CompileCommandsParser::CompileCommand command;
    while (parser.GetNextCommand(command).Succeeded())
    {
      if (g_bVerbose)
      {
        plLog::Info("file: {0}", command.file);
      }
      tmpPath = command.file;
      tmpPath.MakeCleanPath();

      if (IgnorePath(tmpPath))
      {
        continue;
      }

      if (tmpPath.GetFileExtension().Compare_NoCase("cpp") != 0)
      {
        continue;
      }

      auto& context = m_CompilationUnits[tmpPath];

      plDynamicArray<plString> includeFiles;

      command.command.Split(false, commandParts, " ");
      const plUInt32 numParts = commandParts.GetCount();
      for (plUInt32 i = 0; i < numParts; i++)
      {
        auto part = commandParts[i];
        if (part.Compare_NoCase("-isystem") == 0)
        {
          i++;
          part = commandParts[i];
          tmpPath = part;
          tmpPath.MakeCleanPath();

          if (!IgnorePath(tmpPath)) // TODO make command line parameter
          {
            if (g_bVerbose)
            {
              plLog::Info(tmpPath);
            }
            context.m_IncludeDirectories.PushBack(tmpPath);
          }
        }
        else if (part.TrimWordStart("-include"))
        {
          tmpPath = part;
          tmpPath.MakeCleanPath();
          if (g_bVerbose)
          {
            plLog::Info(tmpPath);
          }
          includeFiles.PushBack(tmpPath);
        }
        else if (part.TrimWordStart("-I"))
        {
          tmpPath = part;
          tmpPath.MakeCleanPath();
          if (!IgnorePath(tmpPath))
          {
            if (g_bVerbose)
            {
              plLog::Info(tmpPath);
            }
            context.m_IncludeDirectories.PushBack(tmpPath);
          }
        }
      }

      for (auto& includeFile : includeFiles)
      {
        if (FindIncludeFile(includeFile.GetView(), context, tmpPath).Succeeded())
        {
          context.m_dependencies.Insert(tmpPath);
        }
        else
        {
          if (g_bVerbose)
          {
            plLog::Warning("Could not find include file '{0}' specified on the command line in any include path", includeFile);
          }
        }
      }
    }
  }

  void ParseCompilationUnits()
  {
    struct CompUnit
    {
      plStringView path;
      CompilationUnitContext* context;
    };
    plDynamicArray<CompUnit> compilationUnits;
    compilationUnits.Reserve(m_CompilationUnits.GetCount());

    for (auto& compilationUnit : m_CompilationUnits)
    {
      compilationUnits.PushBack({compilationUnit.Key().GetView(), &compilationUnit.Value()});
    }

    plTaskSystem::ParallelFor(
      compilationUnits.GetArrayPtr(), [this](plArrayPtr<CompUnit> compUnits) {
        plStringBuilder tmpPath;
        DependencyListType dependencies;
        for (auto& compUnit : compUnits)
        {
          plStringView currentFile = compUnit.path;

          PL_LOG_BLOCK("CPP", currentFile);
          dependencies.Clear();
          FindDependencies(currentFile, dependencies);
          for (auto& dependency : dependencies)
          {
            if (!dependency.IsAbsolutePath())
            {
              if (FindIncludeFile(dependency.GetView(), *compUnit.context, tmpPath).Succeeded())
              {
                compUnit.context->m_dependencies.Insert(tmpPath);
              }
              else
              {
                if (g_bVerbose)
                {
                  plLog::Warning("Warning dependency '{0}' of '{1}' not found", dependency, currentFile);
                }
              }
            }
          }
        }
      },
      "ParseCompilationUnit");
  }

  void ParseHeaderFiles()
  {
    plStringBuilder tmpPath;
    plDynamicArray<plSharedPtr<ParseHeaderFileTask>> filesToCheckTasks;

    auto taskGroup = plTaskSystem::CreateTaskGroup(plTaskPriority::EarlyThisFrame);
    for (auto& compilationUnit : m_CompilationUnits)
    {
      for (auto& dependency : compilationUnit.Value().m_dependencies)
      {
        bool existed = false;
        if (auto& dependencies = m_HeaderDependencies.FindOrAdd(dependency.GetView(), &existed); !existed)
        {
          filesToCheckTasks.PushBack(PL_DEFAULT_NEW(ParseHeaderFileTask));
          filesToCheckTasks.PeekBack()->Initialize(dependency.GetView());
          plTaskSystem::AddTaskToGroup(taskGroup, filesToCheckTasks.PeekBack());
        }
      }
    }

    plTaskSystem::StartTaskGroup(taskGroup);
    plTaskSystem::WaitForGroup(taskGroup);

    for (auto& task : filesToCheckTasks)
    {
      m_HeaderDependencies[task->GetPath()] = task->MoveOutDependencies();
    }
  }

  void CheckDependentFiles()
  {
    plDynamicArray<plSharedPtr<CollectDependenciesTask>> tasks;

    for (auto& compilationUnit : m_CompilationUnits)
    {
      tasks.PushBack(PL_DEFAULT_NEW(CollectDependenciesTask));
      tasks.PeekBack()->Initialize(compilationUnit.Key(), compilationUnit.Value(), *this);
    }

    const plUInt32 totalNumTasks = tasks.GetCount();

    // First iteration
    {
      auto group = plTaskSystem::CreateTaskGroup(plTaskPriority::EarlyThisFrame);
      for (auto& task : tasks)
      {
        plTaskSystem::AddTaskToGroup(group, task);
      }
      plTaskSystem::StartTaskGroup(group);
      plTaskSystem::WaitForGroup(group);
    }

    while (true)
    {
      for (plUInt32 i = 0; i < tasks.GetCount();)
      {
        if (tasks[i]->HasWorkLeft())
        {
          tasks[i]->ScheduleRemainingWork();
          ++i;
        }
        else
        {
          tasks.RemoveAtAndSwap(i);
        }
      }

      if (tasks.GetCount() == 0) // If none of the tasks had work left, we are done
      {
        break;
      }

      plLog::Info("Collecting dependencies. Remaining {0} of {1} total", tasks.GetCount(), totalNumTasks);

      plTaskSystem::FinishFrameTasks(); // Wait for parsing tasks to finish before doing the next round of dependency collection

      auto group = plTaskSystem::CreateTaskGroup(plTaskPriority::EarlyThisFrame);
      for (auto& task : tasks)
      {
        plTaskSystem::AddTaskToGroup(group, task);
      }
      plTaskSystem::StartTaskGroup(group);
      plTaskSystem::WaitForGroup(group);
    }
  }

  void WriteOutResults()
  {
    plFileWriter FileOut;

    if (FileOut.Open(m_sOutputPath) == PL_FAILURE)
    {
      plLog::Error("Could not open the file for writing: '{0}'", "results.json");
      return;
    }
    else
    {
      plStringBuilder json;
      json.Append("{\n");
      json.Append(" \"files\" : [\n");

      auto processFile = [this, &json](CompilationUnitListType::Iterator& file) {
        json.Append("    {\n");
        json.AppendFormat("      \"name\" : \"{0}\",\n", file.Key());
        json.Append("      \"dependencies\" :\n");
        json.Append("        [\n");

        auto count = (*file).Value().m_dependencies.GetCount();
        if (count > 0)
        {
          count--;
          auto depIt = (*file).Value().m_dependencies.GetIterator();

          for (plUInt32 i = 0; i < count; ++i, depIt.Next())
          {
            json.AppendFormat("       \"{0}\",\n", (*depIt).GetView());
          }
          json.AppendFormat("       \"{0}\"\n", (*depIt).GetView());
        }
        json.Append("        ]\n");
        json.Append("    }");
      };

      auto count = m_CompilationUnits.GetCount();
      if (count > 0)
      {
        count--;
        auto fileIt = m_CompilationUnits.GetIterator();
        for (plUInt32 i = 0; i < count; ++i, fileIt.Next())
        {
          processFile(fileIt);
          json.Append(",\n");
        }
        processFile(fileIt);
        json.Append("\n");
      }
      json.Append("  ]\n");
      json.Append("}\n");

      FileOut.WriteBytes(json.GetData(), json.GetElementCount()).AssertSuccess();
    }
  }

  static void FindDependencies(plStringView sCurrentFile, DependencyListType& inout_dependencies)
  {
    plStringBuilder fileContents;
    ReadEntireFile(sCurrentFile, fileContents).IgnoreResult();

    auto fileDir = sCurrentFile.GetFileDirectory();

    plTokenizer tokenizer;
    auto dataView = fileContents.GetView();
    auto start = dataView.GetStartPointer();
    auto elementCount = dataView.GetElementCount();
    if (elementCount >= 3 && plUnicodeUtils::SkipUtf8Bom(start))
    {
      elementCount -= 3;
    }
    tokenizer.Tokenize(plArrayPtr<const plUInt8>(reinterpret_cast<const plUInt8*>(start), elementCount), plLog::GetThreadLocalLogSystem());

    plStringView hash("#");
    plStringView include("include");
    plStringView openAngleBracket("<");
    plStringView closeAngleBracket(">");

    auto tokens = tokenizer.GetTokens();
    const auto numTokens = tokens.GetCount();
    for (plUInt32 i = 0; i < numTokens; i++)
    {
      auto curToken = tokens[i];
      while (curToken.m_iType == plTokenType::Whitespace)
      {
        curToken = tokens[++i];
      }
      if (curToken.m_iType == plTokenType::NonIdentifier && curToken.m_DataView == hash)
      {
        do
        {
          curToken = tokens[++i];
        } while (curToken.m_iType == plTokenType::Whitespace);

        if (curToken.m_iType == plTokenType::Identifier && curToken.m_DataView == include)
        {
          auto includeToken = curToken;
          do
          {
            curToken = tokens[++i];
          } while (curToken.m_iType == plTokenType::Whitespace);

          if (curToken.m_iType == plTokenType::String1)
          {
            // #include "bla"
            plStringBuilder absIncludePath;
            plStringBuilder relativePath;
            relativePath = curToken.m_DataView;
            relativePath.Trim("\"");
            relativePath.MakeCleanPath();
            absIncludePath = fileDir;
            absIncludePath.AppendPath(relativePath);

            if (!ExistsFileCache::ExistsFile(absIncludePath))
            {
              inout_dependencies.Insert(relativePath);
            }
            else
            {
              inout_dependencies.Insert(absIncludePath);
            }
          }
          else if (curToken.m_iType == plTokenType::NonIdentifier && curToken.m_DataView == openAngleBracket)
          {
            // #include <bla>
            bool error = false;
            auto startToken = curToken;
            do
            {
              curToken = tokens[++i];
              if (curToken.m_iType == plTokenType::Newline)
              {
                plLog::Error("Non-terminated '<' in #include {0} line {1}", sCurrentFile, includeToken.m_uiLine);
                error = true;
                break;
              }
            } while (curToken.m_iType != plTokenType::NonIdentifier || curToken.m_DataView != closeAngleBracket);

            if (error)
            {
              // in case of error skip the malformed line in hopes that we can recover from the error.
              do
              {
                curToken = tokens[++i];
              } while (curToken.m_iType != plTokenType::Newline);
            }
            else
            {
              plStringBuilder includePath;
              includePath = plStringView(startToken.m_DataView.GetEndPointer(), curToken.m_DataView.GetStartPointer());
              includePath.MakeCleanPath();
              inout_dependencies.Insert(includePath);
            }
          }
          else
          {
            // error
            plLog::Error("Can not parse #include statement in {0} line {1}", sCurrentFile, includeToken.m_uiLine);
          }
        }
        else
        {
          while (curToken.m_iType != plTokenType::Newline && curToken.m_iType != plTokenType::EndOfFile)
          {
            curToken = tokens[++i];
          }
        }
      }
      else
      {
        while (curToken.m_iType != plTokenType::Newline && curToken.m_iType != plTokenType::EndOfFile)
        {
          curToken = tokens[++i];
        }
      }
    }
  }

  virtual plApplication::Execution Run() override
  {
    // something basic has gone wrong
    if (m_bHadSeriousWarnings || m_bHadErrors)
      return plApplication::Execution::Quit;

    auto start = plTimestamp::CurrentTimestamp();

    if (g_bVerbose)
    {
      plLog::Info("Parse compile commands json");
    }
    ParseCompileCommandsJson();

    auto parseJsonEnd = plTimestamp::CurrentTimestamp();

    if (g_bVerbose)
    {
      plLog::Info("Parse compilation units");
    }
    ParseCompilationUnits();

    auto parseCompilationUnitsEnd = plTimestamp::CurrentTimestamp();

    if (g_bVerbose)
    {
      plLog::Info("Parse header files");
    }
    ParseHeaderFiles();

    auto parseHeaderFilesEnd = plTimestamp::CurrentTimestamp();

    if (g_bVerbose)
    {
      plLog::Info("Build dependencies");
    }
    CheckDependentFiles();

    auto checkDependendtFilesEnd = plTimestamp::CurrentTimestamp();

    if (g_bVerbose)
    {
      plLog::Info("Write out results");
    }
    WriteOutResults();

    auto writeOutResultsEnd = plTimestamp::CurrentTimestamp();

    plLog::Info("Time to parse compile commands json: {0}s", (parseJsonEnd - start).AsFloatInSeconds());
    plLog::Info("Time to parse compilation units: {0}s", (parseCompilationUnitsEnd - parseJsonEnd).AsFloatInSeconds());
    plLog::Info("Time to parse header files: {0}s", (parseHeaderFilesEnd - parseCompilationUnitsEnd).AsFloatInSeconds());
    plLog::Info("Time to build dependencies: {0}s", (checkDependendtFilesEnd - parseHeaderFilesEnd).AsFloatInSeconds());
    plLog::Info("Time to write out results: {0}s", (writeOutResultsEnd - checkDependendtFilesEnd).AsFloatInSeconds());
    plLog::Info("Total time taken: {0}s", (writeOutResultsEnd - start).AsFloatInSeconds());

    return plApplication::Execution::Quit;
  }
};

void ParseHeaderFileTask::Execute()
{
  plDependencyAnalysisApp::FindDependencies(m_sPath, m_Dependencies);
}

void CollectDependenciesTask::Execute()
{
  PL_ASSERT_DEBUG(m_pContext != nullptr && m_pApp != nullptr, "Task was not initialized properly");

  auto& compilationUnitDependencies = m_pContext->m_dependencies;

  plDynamicArray<plString> filesToCheck;
  if (m_LeftoverFiles.GetCount() > 0)
  {
    filesToCheck.Swap(m_LeftoverFiles);
    m_ParseTasks.Clear();
  }
  else
  {
    for (auto& include : compilationUnitDependencies)
    {
      filesToCheck.PushBack(include);
    }
  }

  plHashSet<plString> seenFiles;

  while (!filesToCheck.IsEmpty())
  {
    auto include = std::move(filesToCheck.PeekBack());
    filesToCheck.PopBack();

    if (seenFiles.Insert(include))
    {
      continue;
    }

    bool alreadyExisted = false;

    DependencyListType* headerDependencies = nullptr;
    if (!m_pApp->m_HeaderDependencies.TryGetValue(include.GetView(), headerDependencies))
    {
      {
        PL_LOCK(m_pApp->m_HeaderParsingScheduledMutex);
        if (!m_pApp->m_HeaderParsingScheduled.Insert(include.GetView()))
        {
          if (m_ParseTasks.GetCount() == 0)
          {
            m_ParseTaskGroup = plTaskSystem::CreateTaskGroup(plTaskPriority::EarlyThisFrame, plMakeDelegate(&CollectDependenciesTask::OnParsingFinished, this));
          }
          plSharedPtr<ParseHeaderFileTask> task = PL_DEFAULT_NEW(ParseHeaderFileTask);
          task->Initialize(include);
          plTaskSystem::AddTaskToGroup(m_ParseTaskGroup, task);
          m_ParseTasks.PushBack(std::move(task));
        }
      }
    }
    else
    {
      plStringBuilder tmpPath;
      for (auto& dependency : *headerDependencies)
      {
        if (m_pApp->FindIncludeFile(dependency.GetView(), *m_pContext, tmpPath).Succeeded())
        {
          if (!compilationUnitDependencies.Contains(tmpPath.GetView()))
          {
            compilationUnitDependencies.Insert(tmpPath);
            filesToCheck.PushBack(tmpPath);
          }
        }
        else
        {
          if (g_bVerbose)
          {
            plLog::Warning("Failed to find dependency '{0}' of compilation unit '{1}'", dependency, m_sPath);
          }
        }
      }
    }
  }
}

void CollectDependenciesTask::ScheduleRemainingWork()
{
  if (m_ParseTasks.GetCount() > 0)
  {
    plTaskSystem::StartTaskGroup(m_ParseTaskGroup);
  }
}

void CollectDependenciesTask::OnParsingFinished(plTaskGroupID taskGroupId)
{
  PL_LOCK(m_pApp->m_HeaderDependenciesMutex);
  for (auto& task : m_ParseTasks)
  {
    bool alreadyExisted = false;
    auto& deps = m_pApp->m_HeaderDependencies.FindOrAdd(task->GetPath(), &alreadyExisted);
    if (!alreadyExisted)
    {
      deps = task->MoveOutDependencies();
    }
  }
}

PL_CONSOLEAPP_ENTRY_POINT(plDependencyAnalysisApp);
