#pragma once

#include <EditorFramework/EditorFrameworkDLL.h>

#include <Foundation/Reflection/Implementation/StaticRTTI.h>
#include <Foundation/Strings/HashedString.h>
#include <Foundation/Strings/String.h>
#include <Foundation/Time/Timestamp.h>
#include <Foundation/Types/Bitflags.h>
#include <Foundation/Types/Uuid.h>

class plImage;
class plAssetFileHeader;

struct plAssetExistanceState
{
  using StorageType = plUInt8;

  enum Enum : plUInt8
  {
    FileAdded,
    FileRemoved,
    FileMoved,
    FileModified,
    FileUnchanged,
  };
};

struct plAssetDocumentFlags
{
  using StorageType = plUInt8;

  enum Enum
  {
    None = 0,
    AutoTransformOnSave = PL_BIT(0),               ///< Every time the document is saved, TransformAsset is automatically executed
    DisableTransform = PL_BIT(1),                  ///< If set, TransformAsset will not do anything
    OnlyTransformManually = PL_BIT(2),             ///< The asset transformation is not done, unless explicitly requested for this asset
    SupportsThumbnail = PL_BIT(3),                 ///< The asset supports thumbnail generation (InternalCreateThumbnail must be implemented).
    AutoThumbnailOnTransform = PL_BIT(4),          ///< Thumbnail is automatically generated by the asset transform, and does not need to be explicitly created.
    SubAssetsSupportThumbnail = PL_BIT(5),         ///< The sub-asset supports thumbnail generation (InternalCreateThumbnail must be implemented).
    SubAssetsAutoThumbnailOnTransform = PL_BIT(6), ///< Thumbnails for sub-assets are automatically generated by the asset transform, and do not need to be explicitly created.
    Default = None
  };

  struct Bits
  {
    StorageType AutoTransformOnSave : 1;
    StorageType DisableTransform : 1;
    StorageType OnlyTransformManually : 1;
    StorageType SupportsThumbnail : 1;
    StorageType AutoThumbnailOnTransform : 1;
  };
};

PL_DECLARE_FLAGS_OPERATORS(plAssetDocumentFlags);

struct plTransformFlags
{
  using StorageType = plUInt8;

  enum Enum
  {
    None = 0,
    TriggeredManually = PL_BIT(0),    ///< Transform triggered by user directly. Needs to be set to transform assets marked with
                                      ///< plAssetDocumentFlags::Enum::OnlyTransformManually.
    ForceTransform = PL_BIT(1),       ///< Will transform the asset regardless of its current transform state.
    BackgroundProcessing = PL_BIT(2), ///< If changes need to be made that requires re-saving the asset transform will be aborted and plTransformResult::NeedsImport is returned.
    Default = None
  };

  struct Bits
  {
    StorageType TriggeredManually : 1;
    StorageType ForceTransform : 1;
    StorageType BackgroundProcessing : 1;
  };
};
PL_DECLARE_FLAGS_OPERATORS(plTransformFlags);

struct plSubAssetData
{
  plUuid m_Guid;
  plHashedString m_sSubAssetsDocumentTypeName;
  plString m_sName;
};

struct PL_EDITORFRAMEWORK_DLL plAssetDocumentTypeDescriptor : public plDocumentTypeDescriptor
{
  plAssetDocumentTypeDescriptor() = default;
  ~plAssetDocumentTypeDescriptor() = default;

  plString m_sResourceFileExtension;
  plBitflags<plAssetDocumentFlags> m_AssetDocumentFlags;
};


struct plTransformResult
{
  using StorageType = plUInt8;

  enum Enum : plUInt8
  {
    Success = 0,
    Failure,
    NeedsImport,
    Default = Success,
  };
};
PL_DECLARE_REFLECTABLE_TYPE(PL_EDITORFRAMEWORK_DLL, plTransformResult);


struct PL_EDITORFRAMEWORK_DLL plTransformStatus
{
  PL_ALWAYS_INLINE explicit plTransformStatus()
    : m_Result(plTransformResult::Success)
  {
  }

  explicit plTransformStatus(const char* szError)
    : m_Result(plTransformResult::Failure)
    , m_sMessage(szError)
  {
  }

  explicit plTransformStatus(plTransformResult::Enum r, plStringView sError)
    : m_Result(r)
    , m_sMessage(sError)
  {
  }

  explicit plTransformStatus(plStringView sError)
    : m_Result(plTransformResult::Failure)
    , m_sMessage(sError)
  {
  }

  PL_ALWAYS_INLINE plTransformStatus(plTransformResult::Enum r)
    : m_Result(r)
  {
  }

  PL_ALWAYS_INLINE plTransformStatus(plStatus r)
    : m_Result(r.Succeeded() ? plTransformResult::Success : plTransformResult::Failure)
    , m_sMessage(r.m_sMessage)
  {
  }

  PL_ALWAYS_INLINE plTransformStatus(plResult r)
    : m_Result(r.Succeeded() ? plTransformResult::Success : plTransformResult::Failure)
  {
  }

  explicit plTransformStatus(const plFormatString& fmt)
    : m_Result(plTransformResult::Failure)
  {
    plStringBuilder sMsg;
    m_sMessage = fmt.GetText(sMsg);
  }

  PL_ALWAYS_INLINE bool Succeeded() const { return m_Result == plTransformResult::Success; }
  PL_ALWAYS_INLINE bool Failed() const { return m_Result == plTransformResult::Failure; }

  plEnum<plTransformResult> m_Result;
  plString m_sMessage;
};
PL_DECLARE_REFLECTABLE_TYPE(PL_EDITORFRAMEWORK_DLL, plTransformStatus);

PL_ALWAYS_INLINE plResult plToResult(const plTransformStatus& result)
{
  return result.m_Result == plTransformResult::Success ? PL_SUCCESS : PL_FAILURE;
}
