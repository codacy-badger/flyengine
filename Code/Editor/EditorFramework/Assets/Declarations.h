#pragma once

#include <EditorFramework/EditorFrameworkDLL.h>

#include <Foundation/Reflection/Implementation/StaticRTTI.h>
#include <Foundation/Strings/HashedString.h>
#include <Foundation/Strings/String.h>
#include <Foundation/Types/Bitflags.h>
#include <Foundation/Types/Uuid.h>

class plImage;
class plAssetFileHeader;

struct plAssetExistanceState
{
  enum Enum : plUInt8
  {
    FileAdded,
    FileRemoved,
    FileModified,
    FileUnchanged,
  };
};

struct plAssetDocumentFlags
{
  typedef plUInt8 StorageType;

  enum Enum
  {
    None = 0,
    AutoTransformOnSave = PLASMA_BIT(0),      ///< Every time the document is saved, TransformAsset is automatically executed
    DisableTransform = PLASMA_BIT(1),         ///< If set, TransformAsset will not do anything
    OnlyTransformManually = PLASMA_BIT(2),    ///< The asset transformation is not done, unless explicitly requested for this asset
    SupportsThumbnail = PLASMA_BIT(3),        ///< The asset supports thumbnail generation (InternalCreateThumbnail must be implemented).
    AutoThumbnailOnTransform = PLASMA_BIT(4), ///< Thumbnail is automatically generated by the asset transform, and does not need to be explicitly created.
    Default = None
  };

  struct Bits
  {
    StorageType AutoTransformOnSave : 1;
    StorageType DisableTransform : 1;
    StorageType OnlyTransformManually : 1;
    StorageType SupportsThumbnail : 1;
    StorageType AutoThumbnailOnTransform : 1;
  };
};

PLASMA_DECLARE_FLAGS_OPERATORS(plAssetDocumentFlags);

struct plTransformFlags
{
  typedef plUInt8 StorageType;

  enum Enum
  {
    None = 0,
    TriggeredManually = PLASMA_BIT(0),    ///< Transform triggered by user directly. Needs to be set to transform assets marked with
                                      ///< plAssetDocumentFlags::Enum::OnlyTransformManually.
    ForceTransform = PLASMA_BIT(1),       ///< Will transform the asset regardless of its current transform state.
    BackgroundProcessing = PLASMA_BIT(2), ///< If changes need to be made that requires re-saving the asset transform will be aborted and plTransformResult::NeedsImport is returned.
    Default = None
  };

  struct Bits
  {
    StorageType TriggeredManually : 1;
    StorageType ForceTransform : 1;
    StorageType BackgroundProcessing : 1;
  };
};
PLASMA_DECLARE_FLAGS_OPERATORS(plTransformFlags);

struct plSubAssetData
{
  plUuid m_Guid;
  plHashedString m_sSubAssetsDocumentTypeName;
  plString m_sName;
};

struct PLASMA_EDITORFRAMEWORK_DLL plAssetDocumentTypeDescriptor : public plDocumentTypeDescriptor
{
  plAssetDocumentTypeDescriptor() = default;
  ~plAssetDocumentTypeDescriptor() = default;

  plString m_sResourceFileExtension;
  plBitflags<plAssetDocumentFlags> m_AssetDocumentFlags;
};


struct plTransformResult
{
  using StorageType = plUInt8;

  enum Enum : plUInt8
  {
    Success = 0,
    Failure,
    NeedsImport,
    Default = Success,
  };
};
PLASMA_DECLARE_REFLECTABLE_TYPE(PLASMA_EDITORFRAMEWORK_DLL, plTransformResult);


struct PLASMA_EDITORFRAMEWORK_DLL plTransformStatus
{
  PLASMA_ALWAYS_INLINE explicit plTransformStatus()
    : m_Result(plTransformResult::Success)
  {
  }

  explicit plTransformStatus(const char* szError)
    : m_Result(plTransformResult::Failure)
    , m_sMessage(szError)
  {
  }

  explicit plTransformStatus(plTransformResult::Enum r, plStringView sError)
    : m_Result(r)
    , m_sMessage(sError)
  {
  }

  explicit plTransformStatus(plStringView sError)
    : m_Result(plTransformResult::Failure)
    , m_sMessage(sError)
  {
  }

  PLASMA_ALWAYS_INLINE plTransformStatus(plTransformResult::Enum r)
    : m_Result(r)
  {
  }

  PLASMA_ALWAYS_INLINE plTransformStatus(plStatus r)
    : m_Result(r.Succeeded() ? plTransformResult::Success : plTransformResult::Failure)
    , m_sMessage(r.m_sMessage)
  {
  }

  PLASMA_ALWAYS_INLINE plTransformStatus(plResult r)
    : m_Result(r.Succeeded() ? plTransformResult::Success : plTransformResult::Failure)
  {
  }

  explicit plTransformStatus(const plFormatString& fmt)
    : m_Result(plTransformResult::Failure)
  {
    plStringBuilder sMsg;
    m_sMessage = fmt.GetText(sMsg);
  }

  PLASMA_ALWAYS_INLINE bool Succeeded() const { return m_Result == plTransformResult::Success; }
  PLASMA_ALWAYS_INLINE bool Failed() const { return m_Result == plTransformResult::Failure; }

  plEnum<plTransformResult> m_Result;
  plString m_sMessage;
};
PLASMA_DECLARE_REFLECTABLE_TYPE(PLASMA_EDITORFRAMEWORK_DLL, plTransformStatus);

PLASMA_ALWAYS_INLINE plResult plToResult(const plTransformStatus& result)
{
  return result.m_Result == plTransformResult::Success ? PLASMA_SUCCESS : PLASMA_FAILURE;
}
