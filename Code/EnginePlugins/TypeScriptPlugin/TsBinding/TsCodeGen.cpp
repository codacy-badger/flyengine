#include <TypeScriptPlugin/TypeScriptPluginPCH.h>

#include <Foundation/Containers/ArrayMap.h>
#include <Foundation/IO/FileSystem/DeferredFileWriter.h>
#include <Foundation/IO/FileSystem/FileReader.h>
#include <Foundation/IO/FileSystem/FileWriter.h>
#include <TypeScriptPlugin/TsBinding/TsBinding.h>

void plTypeScriptBinding::RemoveAutoGeneratedCode(plStringBuilder& content)
{
  plStringBuilder sFinal;

  {
    if (const char* szAutoGen = content.FindSubString("// AUTO-GENERATED"))
    {
      sFinal.SetSubString_FromTo(content.GetData(), szAutoGen);
    }
    else
    {
      sFinal = content;
    }

    sFinal.Trim(" \t\n\r");
    sFinal.Append("\n\n");
  }

  content = sFinal;
}

void plTypeScriptBinding::AppendToTextFile(plStringBuilder& content, plStringView text)
{
  content.Append("\n\n// AUTO-GENERATED\n");
  content.Append(text);
  content.Append("\n");
}

void plTypeScriptBinding::GenerateEnumsFile(const char* szFile, const plSet<const plRTTI*>& items)
{
  plArrayMap<plString, const plRTTI*> sortedItems;
  plStringBuilder sType, sName;

  for (const plRTTI* pRtti : items)
  {
    if (pRtti->GetProperties().IsEmpty())
      continue;

    sName = pRtti->GetTypeName();
    sName.TrimWordStart("pl");

    sortedItems.Insert(sName, pRtti);
  }

  sortedItems.Sort();

  plStringBuilder sFileContent = "// AUTO-GENERATED FILE\n\n";

  for (plUInt32 i = 0; i < sortedItems.GetCount(); ++i)
  {
    const plRTTI* pRtti = sortedItems.GetValue(i);

    sType.SetFormat("export enum {0} { ", sortedItems.GetKey(i));

    for (auto pProp : pRtti->GetProperties().GetSubArray(1))
    {
      if (pProp->GetCategory() == plPropertyCategory::Constant)
      {
        const plVariant value = static_cast<const plAbstractConstantProperty*>(pProp)->GetConstant();
        const plInt64 iValue = value.ConvertTo<plInt64>();

        sType.AppendFormat(" {0} = {1},", plStringUtils::FindLastSubString(pProp->GetPropertyName(), "::") + 2, iValue);
      }
    }

    sType.Shrink(0, 1);
    sType.Append(" }\n");

    sFileContent.Append(sType.GetView());
  }

  plDeferredFileWriter file;
  file.SetOutput(szFile, true);

  file.WriteBytes(sFileContent.GetData(), sFileContent.GetElementCount()).IgnoreResult();

  if (file.Close().Failed())
  {
    plLog::Error("Failed to write file '{}'", szFile);
    return;
  }
}

void plTypeScriptBinding::InjectEnumImportExport(plStringBuilder& content, const char* szEnumFile)
{
  plStringBuilder sImportExport, sTypeName;

  sImportExport.SetFormat("import __AllEnums = require(\"{}\")\n", szEnumFile);

  plDynamicArray<const plRTTI*> sorted;
  sorted.Reserve(s_RequiredEnums.GetCount());
  for (const plRTTI* pRtti : s_RequiredEnums)
  {
    sorted.PushBack(pRtti);
  }
  sorted.Sort([](const plRTTI* p1, const plRTTI* p2) -> bool { return p1->GetTypeName().Compare(p2->GetTypeName()) < 0; });

  for (const plRTTI* pRtti : sorted)
  {
    GetTsName(pRtti, sTypeName);
    sImportExport.AppendFormat("export import {0} = __AllEnums.{0};\n", sTypeName);
  }

  AppendToTextFile(content, sImportExport);
}

void plTypeScriptBinding::InjectFlagsImportExport(plStringBuilder& content, const char* szFlagsFile)
{
  plStringBuilder sImportExport, sTypeName;

  sImportExport.SetFormat("import __AllFlags = require(\"{}\")\n", szFlagsFile);

  plDynamicArray<const plRTTI*> sorted;
  sorted.Reserve(s_RequiredFlags.GetCount());
  for (const plRTTI* pRtti : s_RequiredFlags)
  {
    sorted.PushBack(pRtti);
  }
  sorted.Sort([](const plRTTI* p1, const plRTTI* p2) -> bool { return p1->GetTypeName().Compare(p2->GetTypeName()) < 0; });

  for (const plRTTI* pRtti : sorted)
  {
    GetTsName(pRtti, sTypeName);
    sImportExport.AppendFormat("export import {0} = __AllFlags.{0};\n", sTypeName);
  }

  AppendToTextFile(content, sImportExport);
}
