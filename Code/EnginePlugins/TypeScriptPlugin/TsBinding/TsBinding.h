#pragma once

#include <TypeScriptPlugin/TypeScriptPluginDLL.h>

#include <Core/Console/ConsoleFunction.h>
#include <Core/ResourceManager/ResourceHandle.h>
#include <Core/Scripting/DuktapeContext.h>
#include <Core/World/Declarations.h>
#include <Core/World/World.h>
#include <Foundation/Configuration/CVar.h>
#include <Foundation/Containers/HashTable.h>
#include <Foundation/Math/Declarations.h>
#include <Foundation/Types/Uuid.h>
#include <TypeScriptPlugin/Resources/ScriptCompendiumResource.h>
#include <TypeScriptPlugin/Transpiler/Transpiler.h>

class plWorld;
class plTypeScriptComponent;
struct plMsgTypeScriptMsgProxy;

using plJavaScriptResourceHandle = plTypedResourceHandle<class plJavaScriptResource>;

enum plTypeScriptBindingIndexProperty
{
  ComponentHandle,
  GameObjectHandle
};

class PLASMA_TYPESCRIPTPLUGIN_DLL plTypeScriptBinding
{
public:
  struct TsMessageHandler
  {
    const plRTTI* m_pMessageType = nullptr;
    plUInt32 m_uiMessageTypeNameHash = 0;
    plString m_sHandlerFunc;
  };

  struct TsComponentInfo
  {
    plString m_sComponentTypeName;
    plHybridArray<TsMessageHandler, 4> m_MessageHandlers;
  };

  using TsComponentTypeInfo = plMap<plUuid, TsComponentInfo>::ConstIterator;

  /// \name Basics
  ///@{

public:
  plTypeScriptBinding();
  ~plTypeScriptBinding();

  plResult Initialize(plWorld& ref_world);
  plResult LoadComponent(const plUuid& typeGuid, TsComponentTypeInfo& out_typeInfo);

  plResult FindScriptComponentInfo(const char* szComponentType, TsComponentTypeInfo& out_typeInfo);

  void RegisterMessageHandlersForComponentType(const char* szComponent, const plUuid& componentType);

  PLASMA_ALWAYS_INLINE plDuktapeContext& GetDukTapeContext() { return m_Duk; }
  PLASMA_ALWAYS_INLINE duk_context* GetDukContext() { return m_Duk.GetContext(); }

  void Update();

private:
  static void GetTsName(const plRTTI* pRtti, plStringBuilder& out_sName);

  plDuktapeContext m_Duk;
  bool m_bInitialized = false;
  plMap<plUuid, bool> m_LoadedComponents;
  plScriptCompendiumResourceHandle m_hScriptCompendium;

  ///@}
  /// \name Typescript Code Generation
  ///@{
public:
  static plResult SetupProjectCode();

private:
  static void GenerateComponentCode(plStringBuilder& out_Code, const plRTTI* pRtti);
  static void GenerateExposedFunctionsCode(plStringBuilder& out_Code, const plRTTI* pRtti);
  static void GeneratePropertiesCode(plStringBuilder& out_Code, const plRTTI* pRtti);
  static void GenerateAllComponentsCode(plStringBuilder& out_Code);
  static void GenerateComponentsFile(const char* szFile);
  static void InjectComponentImportExport(plStringBuilder& content, const char* szComponentFile);
  static void InjectMessageImportExport(plStringBuilder& content, const char* szComponentFile);
  static void GenerateEnumsFile(const char* szFile, const plSet<const plRTTI*>& items);
  static void InjectEnumImportExport(plStringBuilder& content, const char* szEnumFile);
  static void InjectFlagsImportExport(plStringBuilder& content, const char* szEnumFile);
  static void GenerateConstructorString(plStringBuilder& out_String, const plVariant& value);

  static void RemoveAutoGeneratedCode(plStringBuilder& content);
  static void AppendToTextFile(plStringBuilder& content, plStringView text);

  static plSet<const plRTTI*> s_RequiredEnums;
  static plSet<const plRTTI*> s_RequiredFlags;

  ///@}
  /// \name Function Binding
  ///@{

public:
  struct FunctionBinding
  {
    const plAbstractFunctionProperty* m_pFunc = nullptr;
  };

  static const FunctionBinding* FindFunctionBinding(plUInt32 uiFunctionHash);

private:
  static plUInt32 ComputeFunctionBindingHash(const plRTTI* pType, const plAbstractFunctionProperty* pFunc);
  static void SetupRttiFunctionBindings();
  static const char* TsType(const plRTTI* pRtti);
  static int __CPP_Binding_RegisterMessageHandler(duk_context* pDuk);

  static plHashTable<plUInt32, FunctionBinding> s_BoundFunctions;


  ///@}
  /// \name Property Binding
  ///@{

public:
  struct PropertyBinding
  {
    const plAbstractMemberProperty* m_pMember = nullptr;
  };

  static const PropertyBinding* FindPropertyBinding(plUInt32 uiHash);

  static void SyncEzObjectToTsObject(duk_context* pDuk, const plRTTI* pRtti, const void* pObject, plInt32 iObjIdx);
  static void SyncTsObjectEzTsObject(duk_context* pDuk, const plRTTI* pRtti, void* pObject, plInt32 iObjIdx);

private:
  static plUInt32 ComputePropertyBindingHash(const plRTTI* pType, const plAbstractMemberProperty* pMember);
  static void SetupRttiPropertyBindings();

  static plHashTable<plUInt32, PropertyBinding> s_BoundProperties;

  ///@}
  /// \name Message Binding
  ///@{

public:
  plUniquePtr<plMessage> MessageFromParameter(duk_context* pDuk, plInt32 iObjIdx, plTime delay);
  static void DukPutMessage(duk_context* pDuk, const plMessage& msg);

  bool HasMessageHandler(const TsComponentTypeInfo& typeInfo, const plRTTI* pMsgRtti) const;
  bool DeliverMessage(const TsComponentTypeInfo& typeInfo, plTypeScriptComponent* pComponent, plMessage& ref_msg, bool bSynchronizeAfterwards);
  bool DeliverTsMessage(const TsComponentTypeInfo& typeInfo, plTypeScriptComponent* pComponent, const plMsgTypeScriptMsgProxy& msg);

private:
  static void GenerateMessagesFile(const char* szFile);
  static void GenerateAllMessagesCode(plStringBuilder& out_Code);
  static void GenerateMessageCode(plStringBuilder& out_Code, const plRTTI* pRtti);
  static void GenerateMessagePropertiesCode(plStringBuilder& out_Code, const plRTTI* pRtti);

  plInt32 m_iMsgDeliveryRecursion = 0;
  plUuid m_CurrentTsMsgHandlerRegistrator;
  plMap<plUuid, TsComponentInfo> m_TsComponentTypes;


  ///@}
  /// \name Modules
  ///@{
private:
  static int DukSearchModule(duk_context* pDuk);

  ///@}
  /// \name Initialization
  ///@{
private:
  plResult Init_RequireModules();
  plResult Init_Log();
  plResult Init_Utils();
  plResult Init_Time();
  plResult Init_GameObject();
  plResult Init_Component();
  plResult Init_World();
  plResult Init_Clock();
  plResult Init_Random();
  plResult Init_FunctionBinding();
  plResult Init_PropertyBinding();
  plResult Init_Debug();
  plResult Init_Physics();


  ///@}
  /// \name plWorld
  ///@{
public:
  static plWorld* RetrieveWorld(duk_context* pDuk);
  static plTypeScriptBinding* RetrieveBinding(duk_context* pDuk);

  plWorld* GetWorld() { return m_pWorld; }

private:
  void StoreWorld(plWorld* pWorld);

  plWorld* m_pWorld = nullptr;
  static plHashTable<duk_context*, plWorld*> s_DukToWorld;

  ///@}
  /// \name plGameObject
  ///@{
public:
  static plGameObjectHandle RetrieveGameObjectHandle(duk_context* pDuk, plInt32 iObjIdx = 0 /* use 0, if the game object is passed in as the 'this' object (first parameter) */);
  static plGameObject* ExpectGameObject(duk_context* pDuk, plInt32 iObjIdx = 0 /* use 0, if the game object is passed in as the 'this' object (first parameter) */);
  bool DukPutGameObject(const plGameObjectHandle& hObject);
  void DukPutGameObject(const plGameObject* pObject);

  ///@}
  /// \name Components
  ///@{
public:
  void DukPutComponentObject(plComponent* pComponent);
  static plComponentHandle RetrieveComponentHandle(duk_context* pDuk, plInt32 iObjIdx = 0 /* use 0, if the component is passed in as the 'this' object (first parameter) */);

  template <typename ComponentType>
  static ComponentType* ExpectComponent(duk_context* pDuk, plInt32 iObjIdx = 0 /* use 0, if the game object is passed in as the 'this' object (first parameter) */);

  ///@}
  /// \name Math
  ///@{

  static void PushVec2(duk_context* pDuk, const plVec2& value);
  static void SetVec2(duk_context* pDuk, plInt32 iObjIdx, const plVec2& value);
  static void SetVec2Property(duk_context* pDuk, const char* szPropertyName, plInt32 iObjIdx, const plVec2& value);
  static plVec2 GetVec2(duk_context* pDuk, plInt32 iObjIdx, const plVec2& vFallback = plVec2::ZeroVector());
  static plVec2 GetVec2Property(duk_context* pDuk, const char* szPropertyName, plInt32 iObjIdx, const plVec2& vFallback = plVec2::ZeroVector());

  static void PushVec3(duk_context* pDuk, const plVec3& value);
  static void SetVec3(duk_context* pDuk, plInt32 iObjIdx, const plVec3& value);
  static void SetVec3Property(duk_context* pDuk, const char* szPropertyName, plInt32 iObjIdx, const plVec3& value);
  static plVec3 GetVec3(duk_context* pDuk, plInt32 iObjIdx, const plVec3& vFallback = plVec3::ZeroVector());
  static plVec3 GetVec3Property(duk_context* pDuk, const char* szPropertyName, plInt32 iObjIdx, const plVec3& vFallback = plVec3::ZeroVector());

  static void PushMat3(duk_context* pDuk, const plMat3& value);
  static void SetMat3(duk_context* pDuk, plInt32 iObjIdx, const plMat3& value);
  static void SetMat3Property(duk_context* pDuk, const char* szPropertyName, plInt32 iObjIdx, const plMat3& value);
  static plMat3 GetMat3(duk_context* pDuk, plInt32 iObjIdx, const plMat3& mFallback = plMat3::IdentityMatrix());
  static plMat3 GetMat3Property(duk_context* pDuk, const char* szPropertyName, plInt32 iObjIdx, const plMat3& mFallback = plMat3::IdentityMatrix());

  static void PushMat4(duk_context* pDuk, const plMat4& value);
  static void SetMat4(duk_context* pDuk, plInt32 iObjIdx, const plMat4& value);
  static void SetMat4Property(duk_context* pDuk, const char* szPropertyName, plInt32 iObjIdx, const plMat4& value);
  static plMat4 GetMat4(duk_context* pDuk, plInt32 iObjIdx, const plMat4& mFallback = plMat4::IdentityMatrix());
  static plMat4 GetMat4Property(duk_context* pDuk, const char* szPropertyName, plInt32 iObjIdx, const plMat4& mFallback = plMat4::IdentityMatrix());

  static void PushQuat(duk_context* pDuk, const plQuat& value);
  static void SetQuat(duk_context* pDuk, plInt32 iObjIdx, const plQuat& value);
  static void SetQuatProperty(duk_context* pDuk, const char* szPropertyName, plInt32 iObjIdx, const plQuat& value);
  static plQuat GetQuat(duk_context* pDuk, plInt32 iObjIdx, plQuat qFallback = plQuat::IdentityQuaternion());
  static plQuat GetQuatProperty(duk_context* pDuk, const char* szPropertyName, plInt32 iObjIdx, plQuat qFallback = plQuat::IdentityQuaternion());

  static void PushColor(duk_context* pDuk, const plColor& value);
  static void SetColor(duk_context* pDuk, plInt32 iObjIdx, const plColor& value);
  static void SetColorProperty(duk_context* pDuk, const char* szPropertyName, plInt32 iObjIdx, const plColor& value);
  static plColor GetColor(duk_context* pDuk, plInt32 iObjIdx, const plColor& fallback = plColor::White);
  static plColor GetColorProperty(duk_context* pDuk, const char* szPropertyName, plInt32 iObjIdx, const plColor& fallback = plColor::White);

  static void PushTransform(duk_context* pDuk, const plTransform& value);
  static void SetTransform(duk_context* pDuk, plInt32 iObjIdx, const plTransform& value);
  static void SetTransformProperty(duk_context* pDuk, const char* szPropertyName, plInt32 iObjIdx, const plTransform& value);
  static plTransform GetTransform(duk_context* pDuk, plInt32 iObjIdx, const plTransform& fallback = plTransform::IdentityTransform());
  static plTransform GetTransformProperty(duk_context* pDuk, const char* szPropertyName, plInt32 iObjIdx, const plTransform& fallback = plTransform::IdentityTransform());

  static void PushVariant(duk_context* pDuk, const plVariant& value);
  static void SetVariantProperty(duk_context* pDuk, const char* szPropertyName, plInt32 iObjIdx, const plVariant& value);
  static plVariant GetVariant(duk_context* pDuk, plInt32 iObjIdx, const plRTTI* pType);
  static plVariant GetVariantProperty(duk_context* pDuk, const char* szPropertyName, plInt32 iObjIdx, const plRTTI* pType);

  ///@}
  /// \name Debug
  ///@{

public:
  plMap<plString, plUniquePtr<plCVar>> m_CVars;

  struct ConsoleFuncBinding2
  {
    plComponentHandle m_hOwner;
    plUInt32 m_uiFuncStashIdx = 0;
  };

  struct ConsoleFuncBinding
  {
    plUniquePtr<plConsoleFunctionBase> m_pFunc;
    plHybridArray<ConsoleFuncBinding2, 4> m_Registered;
  };

  plMap<plString, ConsoleFuncBinding> m_ConsoleFuncs;

  void StoreConsoleFuncCall(plConsoleFunctionBase* pFunc, const plArrayPtr<plVariant>& params);

private:
  void ExecuteConsoleFuncs();

  struct ConsoleFuncCall
  {
    plConsoleFunctionBase* m_pFunc;
    plHybridArray<plVariant, 4> m_Arguments;
  };

  plHybridArray<ConsoleFuncCall, 4> m_CFuncCalls;

  ///@}
  /// \name C++ Object Registration
  ///@{
public:
  bool RegisterGameObject(plGameObjectHandle hHandle, plUInt32& out_uiStashIdx);
  plResult RegisterComponent(plStringView sTypeName, plComponentHandle hHandle, plUInt32& out_uiStashIdx, bool bIsNativeComponent);

  /// \brief Removes dead GameObject and Component references from the DukTape stash.
  void CleanupStash(plUInt32 uiNumIterations);

  plUInt32 AcquireStashObjIndex();
  void ReleaseStashObjIndex(plUInt32 uiIdx);

private:
  static void StoreReferenceInStash(duk_context* pDuk, plUInt32 uiStashIdx);
  static bool DukPushStashObject(duk_context* pDuk, plUInt32 uiStashIdx);

  static constexpr plUInt32 c_uiMaxMsgStash = 512;
  static constexpr plUInt32 c_uiFirstStashMsgIdx = 512;
  static constexpr plUInt32 c_uiLastStashMsgIdx = c_uiFirstStashMsgIdx + c_uiFirstStashMsgIdx;
  static constexpr plUInt32 c_uiFirstStashObjIdx = c_uiLastStashMsgIdx;
  plUInt32 m_uiNextStashMsgIdx = c_uiFirstStashMsgIdx;
  plUInt32 m_uiNextStashObjIdx = c_uiFirstStashObjIdx;
  plMap<plGameObjectHandle, plUInt32> m_GameObjectToStashIdx;
  plMap<plComponentHandle, plUInt32> m_ComponentToStashIdx;
  plDeque<plUInt32> m_FreeStashObjIdx;
  plMap<plGameObjectHandle, plUInt32>::Iterator m_LastCleanupObj;
  plMap<plComponentHandle, plUInt32>::Iterator m_LastCleanupComp;
  plDynamicArray<plTime> m_StashedMsgDelivery;

  ///@}
};

template <typename ComponentType>
ComponentType* plTypeScriptBinding::ExpectComponent(duk_context* pDuk, plInt32 iObjIdx /*= 0 */)
{
  plComponentHandle hOwnHandle = plTypeScriptBinding::RetrieveComponentHandle(pDuk, iObjIdx);

  ComponentType* pComponent = nullptr;
  plWorld* pWorld = plTypeScriptBinding::RetrieveWorld(pDuk);
  PLASMA_VERIFY(pWorld->TryGetComponent(hOwnHandle, pComponent), "Invalid component parameter");

  return pComponent;
}
